<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Orb Hopper — A small one-file HTML game</title>
  <style>
    :root{
      --bg:#0f1724; --card:#0b1220; --accent:#7dd3fc; --muted:#94a3b8;
      --glass: rgba(255,255,255,0.04);
      --radius:14px;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#071022);color:#e6eef8}
    .wrap{display:grid;place-items:center;height:100%;padding:24px;box-sizing:border-box}
    .card{width:min(980px,96vw);background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:18px;border-radius:16px;box-shadow:0 6px 30px rgba(2,6,23,0.6);}
    header{display:flex;align-items:center;gap:12px;margin-bottom:10px}
    h1{font-size:20px;margin:0}
    .meta{margin-left:auto;color:var(--muted);font-size:13px}
    canvas{display:block;background:linear-gradient(180deg,#07112a 0%, #081428 60%);border-radius:10px;width:100%;height:560px;max-height:70vh}
    .controls{display:flex;gap:10px;align-items:center;margin-top:10px}
    button{background:var(--glass);border:1px solid rgba(255,255,255,0.04);color:var(--accent);padding:8px 12px;border-radius:10px;cursor:pointer}
    .scoreboard{display:flex;gap:14px;align-items:center;color:var(--muted);font-size:14px}
    .hint{color:var(--muted);font-size:13px;margin-top:8px}
    .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
    .panel{background:linear-gradient(180deg,rgba(0,0,0,0.45),rgba(0,0,0,0.25));backdrop-filter:blur(6px);padding:20px;border-radius:12px;border:1px solid rgba(255,255,255,0.03);pointer-events:auto}
    .btn-big{font-size:16px;padding:12px 18px}
    .footer{margin-top:10px;color:var(--muted);font-size:12px}
    /* mobile controls */
    .touch-controls{display:none;gap:12px}
    .touch-controls button{padding:10px 14px;border-radius:10px}
    @media (max-width:700px){
      canvas{height:60vh}
      .touch-controls{display:flex}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card" id="gameCard">
      <header>
        <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='36' height='36' viewBox='0 0 24 24'%3E%3Ccircle cx='12' cy='8' r='3' fill='%237dd3fc'/%3E%3Cpath d='M4 20c0-4.418 3.582-8 8-8s8 3.582 8 8' stroke='%237dd3fc' stroke-width='1.5' fill='none' stroke-linecap='round'/%3E%3C/svg%3E" alt="logo"/>
        <h1>Orb Hopper</h1>
        <div class="meta">Collect orbs • Avoid seekers • Progressive speed</div>
      </header>

      <div style="position:relative">
        <canvas id="c" width="960" height="540"></canvas>
        <div class="overlay" id="overlay" style="display:none;">
          <div class="panel" id="panel">
            <!-- content injected by JS -->
          </div>
        </div>
      </div>

      <div class="controls">
        <div class="scoreboard">
          <div>Score: <strong id="score">0</strong></div>
          <div>High: <strong id="high">0</strong></div>
          <div>Level: <strong id="level">1</strong></div>
        </div>

        <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
          <button id="btnStart" class="btn-big">Start</button>
          <button id="btnPause">Pause</button>
          <button id="btnReset">Reset</button>
        </div>
      </div>

      <div class="hint">Controls: Arrow keys / WASD to move. On mobile use the touch buttons.</div>

      <div class="touch-controls" style="margin-top:10px">
        <button id="t-left">◀</button>
        <button id="t-up">▲</button>
        <button id="t-down">▼</button>
        <button id="t-right">▶</button>
        <button id="t-action">Collect</button>
      </div>

      <div class="footer">Single-file HTML canvas game • Local highscore stored in your browser</div>
    </div>
  </div>

  <script>
  // Orb Hopper — a compact arcade game in one file
  (function(){
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const overlay = document.getElementById('overlay');
    const panel = document.getElementById('panel');
    const scoreEl = document.getElementById('score');
    const highEl = document.getElementById('high');
    const levelEl = document.getElementById('level');
    const btnStart = document.getElementById('btnStart');
    const btnPause = document.getElementById('btnPause');
    const btnReset = document.getElementById('btnReset');

    let W = canvas.width, H = canvas.height;

    // Game state
    let state = 'menu'; // menu, playing, paused, over
    let score = 0, level = 1, high = 0;
    let entities = [];

    // Player
    const player = {
      x: W/2, y: H/2, r: 14, vx:0, vy:0, speed: 220, color: '#7dd3fc'
    };

    // Input
    const keys = {};
    window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; if(e.key===" ") e.preventDefault(); });
    window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

    // touch controls
    ['t-left','t-right','t-up','t-down','t-action'].forEach(id=>{
      const btn=document.getElementById(id); if(!btn) return;
      btn.addEventListener('touchstart',e=>{ e.preventDefault(); keys[id]=true; });
      btn.addEventListener('touchend',e=>{ e.preventDefault(); keys[id]=false; });
      btn.addEventListener('mousedown',e=>{ keys[id]=true; });
      btn.addEventListener('mouseup',e=>{ keys[id]=false; });
    });

    // Utility
    function rand(min,max){ return Math.random()*(max-min)+min }
    function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.sqrt(dx*dx+dy*dy) }

    // Entities: orbs (collect), seekers (enemies), powerups
    function spawnOrb(){
      const o = {type:'orb', x:rand(40,W-40), y:rand(40,H-40), r:9, wob:Math.random()*Math.PI*2, worth:1};
      entities.push(o);
    }
    function spawnSeeker(){
      const side = Math.random()>0.5? 'h':'v';
      let x = rand(20,W-20), y = rand(20,H-20);
      const speed = 40 + (level-1)*20 + Math.random()*40;
      const s = {type:'seeker', x,y,r:16, speed, dir:Math.random()*Math.PI*2, patrol:Math.random()*200+80};
      entities.push(s);
    }

    function spawnPower(){
      const p = {type:'power', x:rand(40,W-40), y:rand(40,H-40), r:11, kind:Math.random()>0.5?'slow':'bonus'};
      entities.push(p);
    }

    // Initial setup
    function resetGame(){
      entities=[]; score=0; level=1; player.x=W/2; player.y=H/2; player.vx=player.vy=0; player.speed=220; state='menu';
      loadHigh(); updateHUD(); showMenu();
    }

    function startGame(){
      entities=[]; score=0; level=1; player.x=W/2; player.y=H/2; player.vx=player.vy=0; player.speed=220; state='playing';
      // spawn initial
      for(let i=0;i<4;i++) spawnOrb();
      for(let i=0;i<Math.min(3,level+1);i++) spawnSeeker();
      scheduleSpawns(); hideOverlay();
    }

    function scheduleSpawns(){
      // spawn more orbs and seekers periodically
      clearTimeout(window._orbSpawn);
      window._orbSpawn = setInterval(()=>{ if(state!=='playing') return; if(Math.random()<0.75) spawnOrb(); if(Math.random()<0.25) spawnPower(); if(Math.random()<0.35) spawnSeeker(); }, 1400 - Math.min(800,(level-1)*80));
    }

    function gameOver(){ state='over'; saveHigh(); showOverlay(gameOverPanel()); }

    // HUD
    function updateHUD(){ scoreEl.textContent = Math.floor(score); highEl.textContent = high; levelEl.textContent = level; }

    function loadHigh(){ try{ high = Number(localStorage.getItem('orbhopper_high')||0); }catch(e){ high=0 } }
    function saveHigh(){ try{ if(score>high){ high=Math.floor(score); localStorage.setItem('orbhopper_high', high); } }catch(e){} }

    // Overlay UI
    function showOverlay(html){ overlay.style.display='flex'; panel.innerHTML=''; if(typeof html === 'string') panel.innerHTML = html; else panel.appendChild(html); }
    function hideOverlay(){ overlay.style.display='none'; panel.innerHTML=''; }

    function showMenu(){ const el = document.createElement('div'); el.innerHTML = `
      <h2 style="margin:0 0 8px 0">Orb Hopper</h2>
      <div style="color:var(--muted);margin-bottom:12px">Collect glowing orbs to score points. Avoid seekers — if they touch you, the run ends. Reach higher levels to increase challenge.</div>
      <div style="display:flex;gap:8px">
        <button id="m-start" class="btn-big">Start</button>
        <button id="m-instruct">How to play</button>
      </div>
    `; showOverlay(el); document.getElementById('m-start').onclick = ()=>{ startGame(); } ; document.getElementById('m-instruct').onclick = ()=>{ showOverlay(instructionPanel()); } }

    function instructionPanel(){ const el=document.createElement('div'); el.innerHTML = `<h3 style="margin:0 0 8px 0">How to play</h3>
      <ul style="color:var(--muted);margin:0 0 12px 18px">
        <li>Move with arrow keys or WASD. On mobile, use the buttons.</li>
        <li>Collect orbs to gain score. Some orbs give combo points.</li>
        <li>Seekers chase slowly but get faster each level.</li>
        <li>Powerups: <strong>slow</strong> temporarily slows seekers; <strong>bonus</strong> gives extra points.</li>
      </ul>
      <div style="display:flex;gap:8px"><button id="i-back">Back</button><button id="i-start" class="btn-big">Start</button></div>`;
      setTimeout(()=>{ el.querySelector('#i-back').onclick=()=>showMenu(); el.querySelector('#i-start').onclick=()=>startGame(); },10);
      return el;
    }

    function gameOverPanel(){ return `<h2 style="margin:0 0 8px 0">Game Over</h2>
      <div style="color:var(--muted);margin-bottom:12px">Score: <strong>${Math.floor(score)}</strong></div>
      <div style="display:flex;gap:8px"><button id="g-retry" class="btn-big">Retry</button><button id="g-menu">Menu</button></div>`;
    }

    // Buttons
    btnStart.addEventListener('click', ()=>{ if(state!=='playing') startGame(); });
    btnPause.addEventListener('click', ()=>{ if(state==='playing'){ state='paused'; showOverlay(pausePanel()); } else if(state==='paused'){ state='playing'; hideOverlay(); }
    });
    btnReset.addEventListener('click', ()=>{ resetGame(); });

    function pausePanel(){ return `<h3 style="margin:0 0 8px 0">Paused</h3><div style="display:flex;gap:8px"><button id="p-resume" class="btn-big">Resume</button><button id="p-menu">Menu</button></div>` }

    overlay.addEventListener('click', (e)=>{
      // clicks outside panel should not close; only buttons inside control it
    });

    // Main loop
    let last = performance.now();
    function resizeCanvas(){ const rect = canvas.getBoundingClientRect(); // adjust internal size for crispness
      const ratio = window.devicePixelRatio || 1; canvas.width = Math.max(400, Math.floor(rect.width * ratio)); canvas.height = Math.max(300, Math.floor(rect.height * ratio)); W = canvas.width; H = canvas.height; ctx.setTransform(ratio,0,0,ratio,0,0);
    }
    window.addEventListener('resize', () => { resizeCanvas(); });
    resizeCanvas();

    function update(dt){ if(state!=='playing') return;
      // Input movement
      let dx=0, dy=0;
      if(keys['arrowleft']||keys['a']||keys['t-left']) dx -= 1;
      if(keys['arrowright']||keys['d']||keys['t-right']) dx += 1;
      if(keys['arrowup']||keys['w']||keys['t-up']) dy -= 1;
      if(keys['arrowdown']||keys['s']||keys['t-down']) dy += 1;
      const len = Math.hypot(dx,dy);
      if(len>0){ player.vx = (dx/len)*player.speed; player.vy = (dy/len)*player.speed; }
      else{ player.vx = player.vy = 0; }

      player.x += player.vx * dt; player.y += player.vy * dt;
      // keep in bounds
      player.x = Math.max(player.r, Math.min((W/ (window.devicePixelRatio||1)) - player.r, player.x));
      player.y = Math.max(player.r, Math.min((H/ (window.devicePixelRatio||1)) - player.r, player.y));

      // Entities behaviour
      for(let i=entities.length-1;i>=0;i--){ const e = entities[i];
        if(e.type==='orb'){
          e.wob += dt*6; // wobble
          // collision with player
          if(circleCollide(player,e)){
            score += e.worth * (1 + Math.floor(level*0.2));
            // small chance to spawn combo orb
            if(Math.random()<0.12){ for(let k=0;k<2;k++) spawnOrb(); }
            entities.splice(i,1); spawnOrb(); // replace
            updateProgress();
          }
        } else if(e.type==='seeker'){
          // basic chasing behaviour
          const px = player.x, py = player.y;
          const dx = px - e.x, dy = py - e.y;
          const d = Math.hypot(dx,dy) || 1; e.dir = Math.atan2(dy,dx);
          const sp = e.speed * (1 + (level-1)*0.06);
          e.x += Math.cos(e.dir) * sp * dt; e.y += Math.sin(e.dir) * sp * dt;
          // bounce at edges
          e.x = Math.max(e.r, Math.min((W/(window.devicePixelRatio||1))-e.r, e.x));
          e.y = Math.max(e.r, Math.min((H/(window.devicePixelRatio||1))-e.r, e.y));
          // collision -> game over
          if(circleCollide(player,e)){
            gameOver();
          }
        } else if(e.type==='power'){
          // simple time-limited float
          e.y += Math.sin(performance.now()/300 + e.x) * 0.2;
          if(circleCollide(player,e)){
            if(e.kind==='slow'){
              // slow seekers temporarily
              slowSeekers(3000);
            } else {
              score += 10 + level*2;
            }
            entities.splice(i,1);
          }
        }
      }

      // Level progression
      const target = 20 + level*10;
      if(score >= target){ levelUp(); }

      updateHUD();
    }

    function slowSeekers(ms){ entities.forEach(e=>{ if(e.type==='seeker'){ e.speed *= 0.5; } }); setTimeout(()=>{ entities.forEach(e=>{ if(e.type==='seeker'){ e.speed *= 2; } }); }, ms); }

    function levelUp(){ level++; // add some enemies and orbs
      for(let i=0;i<2;i++) spawnSeeker(); for(let i=0;i<3;i++) spawnOrb(); player.speed += 8; updateHUD(); }

    function updateProgress(){ // small progression effect: slightly increase score multipliers, maybe spawn extra
      if(Math.random()<0.1) spawnPower();
    }

    function circleCollide(a,b){ const dx=a.x-b.x, dy=a.y-b.y; const r = (a.r||0)+(b.r||0); return dx*dx+dy*dy <= r*r; }

    function draw(){ // clear
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // background subtle grid
      drawBackground();

      // draw orbs and entities
      for(const e of entities){ if(e.type==='orb') drawOrb(e); else if(e.type==='seeker') drawSeeker(e); else if(e.type==='power') drawPower(e); }

      // draw player
      drawPlayer();

      // hud (small)
      // crosshair
      ctx.save(); ctx.globalAlpha = 0.08; ctx.beginPath(); ctx.arc(player.x, player.y, player.r*2.6, 0, Math.PI*2); ctx.fillStyle = '#7dd3fc'; ctx.fill(); ctx.restore();
    }

    function drawBackground(){ const cols = 24; const rows = 13; const stepX = (W/(window.devicePixelRatio||1))/cols; const stepY = (H/(window.devicePixelRatio||1))/rows; ctx.save(); ctx.globalAlpha=0.06; ctx.strokeStyle='#7dd3fc'; ctx.lineWidth=1;
      for(let i=0;i<=cols;i++){ ctx.beginPath(); ctx.moveTo(i*stepX,0); ctx.lineTo(i*stepX, H/(window.devicePixelRatio||1)); ctx.stroke(); }
      for(let j=0;j<=rows;j++){ ctx.beginPath(); ctx.moveTo(0,j*stepY); ctx.lineTo(W/(window.devicePixelRatio||1), j*stepY); ctx.stroke(); }
      ctx.restore();
    }

    function drawOrb(o){ const x=o.x,y=o.y,r=o.r; ctx.save(); const pulse = Math.sin(o.wob)*0.6+1; const grd = ctx.createRadialGradient(x,y,r*0.1,x,y,r*1.6); grd.addColorStop(0,'rgba(125,211,252,0.98)'); grd.addColorStop(0.6,'rgba(125,211,252,0.28)'); grd.addColorStop(1,'rgba(125,211,252,0.06)'); ctx.fillStyle=grd; ctx.beginPath(); ctx.arc(x,y,r*pulse,0,Math.PI*2); ctx.fill(); ctx.restore(); }

    function drawSeeker(s){ ctx.save(); ctx.beginPath(); ctx.fillStyle = '#ff758f'; ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fill(); // eye
      ctx.beginPath(); ctx.fillStyle='rgba(0,0,0,0.3)'; ctx.arc(s.x + Math.cos(s.dir)*s.r*0.4, s.y + Math.sin(s.dir)*s.r*0.4, s.r*0.28,0,Math.PI*2); ctx.fill(); ctx.restore(); }

    function drawPower(p){ ctx.save(); ctx.beginPath(); ctx.fillStyle = p.kind==='slow' ? '#a78bfa' : '#fde68a'; ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill(); ctx.restore(); }

    function drawPlayer(){ ctx.save(); // glow
      ctx.beginPath(); const g = ctx.createRadialGradient(player.x,player.y,player.r*0.1, player.x,player.y, player.r*2.8); g.addColorStop(0, 'rgba(125,211,252,0.95)'); g.addColorStop(0.6, 'rgba(125,211,252,0.18)'); g.addColorStop(1,'rgba(125,211,252,0.02)'); ctx.fillStyle = g; ctx.arc(player.x,player.y,player.r*1.6,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.fillStyle = player.color; ctx.arc(player.x,player.y,player.r,0,Math.PI*2); ctx.fill(); ctx.restore(); }

    function loop(now){ const dt = Math.min(0.04, (now-last)/1000); last = now; update(dt); draw(); requestAnimationFrame(loop); }
    requestAnimationFrame(loop);

    // overlay button handlers created after content insertion
    const observer = new MutationObserver(()=>{
      // wire overlay buttons when present
      const retry = document.getElementById('g-retry'); if(retry) { retry.onclick = ()=>{ startGame(); hideOverlay(); } }
      const gmenu = document.getElementById('g-menu'); if(gmenu){ gmenu.onclick = ()=>{ resetGame(); } }
      const iBack = document.getElementById('i-back'); if(iBack){ iBack.onclick = ()=>{ showMenu(); } }
      const pResume = document.getElementById('p-resume'); if(pResume){ pResume.onclick = ()=>{ state='playing'; hideOverlay(); } }
      const pMenu = document.getElementById('p-menu'); if(pMenu){ pMenu.onclick = ()=>{ resetGame(); } }
    }); observer.observe(panel, {childList:true, subtree:true});

    // initial display
    loadHigh(); updateHUD(); showMenu();

    // Reset button behaviour
    btnReset.addEventListener('click', ()=>{ resetGame(); });

    // keyboard space to toggle pause
    window.addEventListener('keydown', e=>{ if(e.key===' '){ if(state==='playing'){ state='paused'; showOverlay(pausePanel()); } else if(state==='paused'){ state='playing'; hideOverlay(); } } });

    // helper: show game over panel when state is over
    const stateWatcher = setInterval(()=>{
      if(state==='over'){ hideOverlay(); showOverlay(gameOverPanel()); }
    },200);

  })();
  </script>
</body>
</html>
